# $${\color{lightblue} Tarjan \space 's \space Algorithm}$$

This Algorithm is used to find the Strongly Connected Components.

----

The code defines the data variables which will be present in each Node of the graph while performing Tarjan 's Algorithm.

```java
// Node class storing the data variables...
    public class Node {
        int key;        // The Node value...
        int found;      // The time when node was first visited...
        int lowLink;    // The minimum time among all nodes in the SCC...
        List<Integer> toNodes;      // Storing the next neighbors...
        boolean onStack;        // Flag to store whether the node is in Stack or not...

        public Node(int key) {  // Parametrized Constructor...
            this.key = key; this.lowLink = 0; this.toNodes = new ArrayList<Integer>();
            this.onStack = false; this.found = -1;      // Marking nodes not reached as -1...
        }
    }
```

This defines the global variables and the start function of the Algorithm.

```java
Stack<Integer> stack = new Stack<Integer>();    // Stack to store the stack of Nodes...
    public static int time = 0;     // Global time value...
    List<List<Integer>> sccs = new ArrayList<>();   // List storing all SCCs in the graph...
    List<List<Integer>> critical = new ArrayList<>();     // List to store critical connections...

    public int algorithm(int n, int edges[][]) {
        Node[] nodes = new Node[n];     // Array Initialization of Nodes...
        for(int i = 0; i < nodes.length; i++)
            nodes[i] = new Node(i);     // Instantiation...
        for(int edge[] : edges)     // Adding edges and vertices in the graph...
            nodes[edge[0]].toNodes.add(edge[1]);
        return findStronglyConnectedComponents(nodes);      // Counting number of SCCs...
    }
```

Then we find the Strongly Connected Components and return the count.

```java
public int findStronglyConnectedComponents(Node[] nodes) {
        for(int i = 0; i < nodes.length; i++)
            if(nodes[i].found == -1)    // If the node is not yet visited...
                depthFirstSearch(i, nodes);     // Perform DFS...
        return sccs.size();
    }
```

Finally we use the main Logic of Tarjan Algorithm to find the Strongly Connected Component using Stack and Backtracking.

```java
public void depthFirstSearch(int node, Node[] nodes) {
        // Update the first visit time and its low-link value using global time variable...
        nodes[node].found = nodes[node].lowLink = time++;
        stack.push(node);       // Push the node into the stack...
        nodes[node].onStack = true;     // Mark the node as present in the stack...
        for(int neighbor : nodes[node].toNodes) {
            // If the neighbor node is not visited...
            if(nodes[neighbor].found == -1) {
                depthFirstSearch(neighbor, nodes);  // Perform DFS on the neighbor...
                // Update the low-link value as the min, assuming the current node is in the SCC...
                nodes[node].lowLink = Math.min(nodes[node].lowLink, nodes[neighbor].lowLink);
                // If low-link fo neighbor greater than first visit time of parent node, then it is a different SCC...
                if(nodes[neighbor].lowLink > nodes[node].found)
                    critical.add(Arrays.asList(node, neighbor));
            }
            // If neighbor node is in the stack (it is reached a second time)...
            else if(nodes[neighbor].onStack) {
                // Update the low-link of parent node as the min of parent and neighbor low-link...
                nodes[node].lowLink = Math.min(nodes[node].lowLink, nodes[neighbor].found);
            }
        }
        // If the visit time and low-link of the node is same, then we have reached the root of the SCC...
        if(nodes[node].lowLink == nodes[node].found) {
            List<Integer> scc = new ArrayList<Integer>();
            int w;
            do {    // Backtracking...
                w = stack.pop();    // Popping from the stack...
                nodes[w].onStack = false;   // During popping we reverse the onStack state (backtracking)...
                scc.add(w);
            } while(w != node);     // While the root of the SCC is not reached...
            sccs.add(scc);      // Add the SCC to the list of SCCs...
        }
        return;
    }
```

